**343.整数拆分**

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

思路：

1.确定`dp[i]`的含义：`dp[i]`就是给定数字`i`，拆分之后得到的最大的乘积。

2.递推公式：**这一步是最不好想的，着重说一下。**

例如给出数字6，我们可以这么拆分。

`dp[2] = 1x1`

`dp[3] = 1x2`

`dp[4] = 2x2`

`dp[5] = 2x3`

`dp[6]可以拆成1x5，2x4，3x3，4x2，5x1.`

对于1x5来说，1x5是一种结果，当然也可以继续拆分5，拆分5得到的最大乘积就是`dp[5]`（我们对`dp`数组的定义）所以说可以将1x5与1x`dp[5]`进行比较取最大值。映射到`i，j`上其实就是`i`是普通数字，`j`就是从1开始递增的1x5里的1，2x4里的2。那么5和4就是`(i-j)`。`i`从3开始把最大结果一直算出来，直到`i`=n，这时候才能得到最终的答案。

3.`dp`数组如何初始化：因为`n>=2`,所以`dp[2] = 1`

4.遍历顺序：外层`i`循环控制数字，内层`j`循环控制`j`从1递增到`i-1`同时更新最大值。递增到`i-1`是因为如果递增到`i`的话，`(i-j)`就变成0了

5.打印`dp`数组

```c#
public class Solution {
    public int IntegerBreak(int n) {
        int[] dp = new int[59];
        dp[1] = 1;
        dp[2] = 1*1;
        for(int i = 3;i<=n;i++){
            for(int j = 1;j<i;j++){
                dp[i] = Math.Max(dp[i], Math.Max(j * (i - j), j * dp[i - j]));
                //当前dp值和 Max.(不拆(i-j)，拆(i-j)）取最大值
            }
        }
        return dp[n];
    }
}
```

[动态规划，本题关键在于理解递推公式！| LeetCode：343. 整数拆分_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Mg411q7YJ?spm_id_from=333.788.videopod.sections&vd_source=157a35c74b3126ceb8ea1890e7f45f07)
