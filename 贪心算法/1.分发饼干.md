**455.分发饼干**

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。

```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。
所以你应该输出 1
```

思路：局部最优推出全局最优，就是把饼干和小孩胃口从小到大排序好。从最大的饼干开始尝试满足胃口最大的孩子。

```c#
public class Solution {
    public int FindContentChildren(int[] g, int[] s) {
        // 使用贪心算法：优先用大饼干满足大胃口的孩子
        // 时间复杂度：O(n logn + m logm)，空间复杂度：O(1)

        // 将孩子的胃口值(g)和饼干尺寸(s)分别排序
        Array.Sort(g); // 孩子数组从小到大排序
        Array.Sort(s); // 饼干数组从小到大排序

        int count = 0;            // 统计满足的孩子数量
        int cookieIndex = s.Length - 1; // 从最大的饼干开始分配

        // 逆序遍历孩子数组（从最大的胃口开始尝试满足）
        for (int i = g.Length - 1; i >= 0; i--) {
            // 当还有剩余饼干，且当前饼干能满足当前孩子的胃口时
            if (cookieIndex >= 0 && s[cookieIndex] >= g[i]) {
                count++;          // 满足一个孩子
                cookieIndex--;    // 该饼干已被使用，移动到更小的饼干
            }
            // 如果当前饼干不能满足，则跳过这个孩子（用这个饼干尝试满足胃口更小的孩子）
        }

        return count; // 返回最大满足数量
    }
}
```

这个解答里面没有使用双层for循环，而是使用一个index移动饼干索引，这也是常用的一个方法。

[贪心算法，你想先喂哪个小孩？| LeetCode：455.分发饼干_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1MM411b7cq?spm_id_from=333.788.videopod.sections&vd_source=01ce83bfd26f457fbdf4e6ed8df8d6ad)